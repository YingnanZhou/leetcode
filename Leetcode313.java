class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        //the next ugly number is generated by previous ugly number, to make our result sorted, we use a min heap to trace the previous minimum ugly number.
        //for example, we have 1 in heap, 
        //first round we compare 1 * 2, 1 * 7, 1 * 13, 1 * 19, we got 2 as minimum, where 1 is nums[0]
        //next round we compare 2 * 2, 1 * 7, 1 * 13, 1 * 19, cause we chose 1 * 2, so for 2, we move one step further, from nums[0] to nums[1].
        
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) ->(a[0] - b[0]));
        //the ugly number after 1 must come from the primes list
        for(int i = 0; i < primes.length; i++) 
            queue.offer(new int[]{primes[i], primes[i], 0});
        
        int[] nums = new int[n];
        nums[0] = 1;
        
        int i = 1;
        while(i < n) {
            int[] cur = queue.poll();
            int num = cur[0], prime = cur[1], index = cur[2];
            //remove duplicates
            if(num != nums[i - 1]) {
                nums[i] = num;
                i++;
            }
            queue.offer(new int[]{prime * nums[index + 1], prime, index + 1});
        }
        return nums[n - 1];
    }
}